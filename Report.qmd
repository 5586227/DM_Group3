---
title: "Report pdf"
format: pdf
editor: visual
---

## 

## Part 1: Database Design and Implementation

### Task 1.1: E-R Diagram

#### Entities

Our E-R Diagram for an E-commerce database consisted of seven main entities:

1.  CUSTOMER: Represents details of individuals or entities who purchase products, including attributes such as customer ID, customer name, contact information, and gender. 
2.  PRODUCT: Represents details of items available for sale, including attributes such as product ID, product name, description, rating, price, and available stock. 
3.  ADVERTISEMENT: Represents details of promotional activities used to advertise products, including attributes such as advertisement ID, number of times the advertisement is shown, cost of the advertisement, and the place the advertisement was placed. 
4.  SUPPLIER: Represents details of entities providing products to businesses or customers, including attributes such as supplier ID, supplier name, and contact information. 
5.  CATEGORY: Represents product classifications or groupings, including attributes such as category unique ID, name, and fee amount as a percentage.

#### Relationships + \<paste relationship set\>

The relationships among these entities are as follows: 

-   CUSTOMER and PRODUCT have an M-N relationship meaning one customer can order many products, and one product can be ordered by many customers.

    The relationship is shown as ORDER, representing a customer placing an order to purchase products. It also contains some attributes to store the details of each order, including order ID, order date, order status, order quantity, promo code, payment method, and delivery fee.

-   **\<?????\>**PRODUCT has a self-referencing relationship of 1 to many. The relationship is shown as Sold_Together, indicating that one product can be sold together with others as a bundle.

-   PRODUCT and ADVERTISEMENT have an M-N relationship. This relationship is shown as ADVERTIIE_IN to reflect products presented in the advertisements, meaning multiple advertisements can promote one product, and one advertisement can promote multiple products. 

-   PRODUCT and SUPPLIER have an N-1 relationship, indicating that one product can be supplied by only one supplier, but one supplier can provide multiple products. 

-   PRODUCT and CATEGORY have an N-1 relationship, meaning one product can belong to only one category, but one category can contain multiple products. 

As a result, this is our E-R diagram.

![](images/E-R%20Diagram(Final)-Before%20Final.drawio.png)

### Task 1.2: SQL Database Schema Creation

#### Normalization:

According to our first draft of the E-R diagram, two main adjustments were made in order to comply with 3NF

The first adjustment was on the ORDER table. After reviewing the order of normal forms, it was found that the ORDER entity still did not comply with 3NF.

Functional Dependency:

{order_id, customer_id, product_id } -\> { order_date , order_status, order_quantity, promo_code, discount amount, payment_method, delivery_fee}

{promo_code} -\> { discount_amount}

As we assumed that order_id could be duplicated to represent products ordered by the same customer simultaneously, there would be UPDATE anomalies. If there is an update on any attributes, such as payment_methods, we must alter more than one row in case there is more than one product in that order_id. In addition, discount_amount is also transitively dependent on promo_code.

Therefore, we separated the ORDER table into three entities including:

1.  ORDER_DETAIL is similar to the ORDER table but has fewer attributes to contain each order's details. It has product_id as a primary key, customer_id and promo_code as foreign keys, and other attributes like order_date, order_status, and payment_method.
2.  ORDER_ITEM contains product IDs and the quantities ordered in each order. The table has order_id and product_id as foreign keys and a composite primary key, and quantity as another attribute.
3.  DISCOUNT is created to store the data of available promotional discounts, which consists of promo_code as a primary key and discount_amount.

The next adjustment was on the CUSTOMER table, which was initially on 2NF. Based on its function dependency, street, city, and country can also be determined by postcode and customer_id.

Functional Dependency:

{customer_id} -\>{ first_name , last_name , gender , email, mobile_no , street , city , country , postcode } {postcode} -\> { street, city , country }

This indicated that street, city, and country were transitively dependent on postcode. As a result, a new table is created as ADDRESS, which has postcode as a primary key and stores street, city, and country as other attributes.

In summary, four new entities were created from the Normalisation, which were ORDER_DETAIL, ORDER_ITEM, DISCOUNT, and ADDRESS.

#### Logical Schema \<update\>

According to the E-R diagram, we can list logical schema as follows:

-   CUSTOMER([customer_ID]{.underline}, first_name, last_name, gender, email, mobile_no, street, city, country, postcode) 

-   PRODUCT([product_ID]{.underline}, product_name, product_description, unit_price, stock_at_hand) 

-   ADVERTISEMENT([ad_id]{.underline}, ad_number, ad_place, ad_price, product_ID) 

-   SUPPLIER([supplier_id]{.underline}, supplier_name, email, mobile_no) 

-   CATEGORY([category_id,]{.underline} category_name, category_fee)

#### Physical Schema \<update\>

```{r, echo=FALSE}

library(DBI)
library(RSQLite)

#install.packages("DBI")
#install.packages("RSQLite")
```

Firstly, we created a connection to our database named "database.db"

```{r}
connect <- dbConnect(RSQLite::SQLite(), "database.db")
```

Then, we first created parent entities, including CUSTOMER, DISCOUNT, ADVERTISEMENT, SUPPLIER, and CATEGORY.

1.  Create CUSTOMER entity

    ```{sql connection=connect}
    CREATE TABLE CUSTOMER (
      customer_id VARCHAR(250) PRIMARY KEY, 
      first_name VARCHAR(250) NOT NULL,
      last_name VARCHAR(250) NOT NULL,
      gender VARCHAR(10),
      customer_email VARCHAR(250) NOT NULL,
      customer_mobile VARCHAR(15) NOT NULL
    );
    ```

2.  Create ADDRESS table

    ```{sql connection=connect}
    CREATE TABLE ADDRESS (
      postcode VARCHAR(20) PRIMARY KEY, 
      customer_id INT NOT NULL,
      street VARCHAR(50) NOT NULL,
      city VARCHAR(100) NOT NULL,
      country VARCHAR(100) NOT NULL,
      FOREIGN KEY (customer_id)
        REFERENCES CUSTOMER (customer_id)
    );
    ```

3.  Create DISCOUNT entity

    ```{sql connection=connect}
    CREATE TABLE DISCOUNT (
      promo_code VARCHAR(20) PRIMARY KEY, 
      discount_amount INT NOT NULL
    );
    ```

4.  Create ADVERTISEMENT entity

    ```{sql connection=connect}
    CREATE TABLE ADVERTISEMENT (
      ad_id VARCHAR(250) PRIMARY KEY, 
      ad_frequency INT NOT NULL,
      ad_place VARCHAR(50) NOT NULL,
      ad_price DECIMAL(10, 2) NOT NULL, 
    );
    ```

5.  Create SUPPLIER entity

    ```{sql connection=connect}
    CREATE TABLE SUPPLIER (
      supplier_id VARCHAR(250) PRIMARY KEY, 
      supplier_name VARCHAR(250) NOT NULL,
      supplier_email VARCHAR(250) NOT NULL,
      supplier_mobile VARCHAR(20) NOT NULL
    );
    ```

6.  Create CATEGORY entity

    ```{sql connection=connect}
    CREATE TABLE CATEGORY (
      category_id VARCHAR(250) PRIMARY KEY, 
      category_name VARCHAR(250) NOT NULL,
      category_fee INT NOT NULL,
    );
    ```

Then, we created children entities, which are PRODUCT

6.  Create PRODUCT entity

    ```{sql connection=connect}
    CREATE TABLE PRODUCT (
      product_id VARCHAR(250) PRIMARY KEY, 
      product_name VARCHAR(250) NOT NULL,
      product_description VARCHAR(250),
      product_rating DECIMAL(5,2),
      unit_price DECIMAL(10,2) NOT NULL,
      stock_on_hand INT NOT NULL,
      main_product_id INT,
      category_id INT NOT NULL,
      supplier_id INT NOT NULL,
      FOREIGN KEY (supplier_id)
        REFERENCES SUPPLIER (supplier_id),
      FOREIGN KEY (category_id)
        REFERENCES CATEGORY (category_id)
    );
    ```

We also created new entities that are from many-to-many relationships, including ORDER_ITEM, ORDER_DETAIL, and ADVERTISE_IN

7.  Create ORDER_ITEM and ORDER_DETAIL entities for CUSTOMER-PRODUCT relationship

    ```{sql connection=connect}
    CREATE TABLE ORDER_ITEM (
      order_id VARCHAR(250) PRIMARY KEY,
      product_id VARCHAR(250), 
      order_quantity INT NOT NULL,
      FOREIGN KEY (product_id)
        REFERENCES PRODUCT (product_id)
    );

    ```

    ```{sql connection=connect}
    CREATE TABLE ORDER_DETAIL (
      order_id VARCHAR(250) PRIMARY KEY,
      customer_id VARCHAR(250), 
      order_date DATE NOT NULL,
      order_status VARCHAR(50) NOT NULL, 
      promo_code VARCHAR(20),
      payment_method TEXT NOT NULL,
      FOREIGN KEY (customer_id)
        REFERENCES CUSTOMER (customer_id),
      FOREIGN KEY (order_id)
        REFERENCES CUSTOMER (customer_id),
      FOREIGN KEY (promo_code)
        REFERENCES DISCOUNT (promo_code)
    );
    ```

8.  Create ADVERTISE_IN entity for PRODUCT-ADVERTISEMENT relationship

    ```{sql connection=connect}
    CREATE TABLE ADVERTISE_IN (
      product_id VARCHAR(250),
      ad_id VARCHAR(250),
      PRIMARY KEY (product_id, ad_id),
      FOREIGN KEY (product_id) REFERENCES PRODUCT (product_id),
      FOREIGN KEY (ad_id) REFERENCES ADVERTISEMENTS (ad_id)
    );
    ```

## Part 2: Data Generation and Implementation

### Task 2.1: Synthetic Data Generation

The synthetic data of each table was created based on the normalised schema using Mockaroo, a mock data generator platform.

The number of observation data generated for each entity was as followed:

-   50 observations for ADDRESS

-   50 observations for ADVERTISE_IN

-   5 observations for ADVERTISEMENT

-   5 observations for CATEGORY

-   50 observations for CUSTOMER

-   5 observations for DISCOUNT

-   100 observations for ORDER_DETAIL

-   100 observations for ORDER_ITEM

-   50 observations for PRODUCT

-   50 observations for SUPPLIER

### Task 2.2: Data Import and Quality Assurance

#### Data Import

Loading all generated data sets using read_csv to each entity

```{r}
customer <- readr::read_csv("CUSTOMER.csv")
address <- readr::read_csv("ADDRESS.csv")
supplier <- readr::read_csv("SUPPLIER.csv")
category <- readr::read_csv("CATEGORY.csv")
advertisement <- readr::read_csv("ADVERTISEMENT.csv")
discount <- readr::read_csv("DISCOUNT.csv")
product <- readr::read_csv("PRODUCT.csv")
order_item <- readr::read_csv("ORDER_ITEM.csv")
order_detail <- readr::read_csv("ORDER_DETAIL.csv")
advertise_in <- readr::read_csv("ADVERTISE_IN.csv")
```

#### Quality Assurance

The imported data sets were validated before being added to the database to ensure that they aligned with the nature of the keys and data type specified in the physical schema. Parent entities, which are CUSTOMER, SUPPLIER, CATEGORY, ADVERTISEMENT, and DISCOUNT, would be validated first. Once all parent entities were validated, we would continue validating child entities consisting of PRODUCT, ORDER_ITEM, ORDER_DETAIL, and ADVERTISE_IN.

**Parent Entities Validation**

1.  CUSTOMER

    Validation processes for CUSTOMER entity included:

    -   Check if the values of the primary key are unique

    -   Check the format of the customers' first and last names. The format is expected to be first uppercase alphabet followed by lowercase alphabet.

    -   Check the format of the email

    -   Check the format of the mobile number, which should start with a plus sign followed by 12 integer values

    -   Check if there is any missing data in the attributes that should not have missing values

    -   Remove unqualified data values

    ```{r}
    #Check for duplicate primary key
    duplicate_customer_id <- customer[duplicated(customer$customer_id), "customer_id"] 

    #Check format of first and last name (1st alphabet is uppercase, rest is lowercase)
    invalid_customer_firstname <- customer[!grepl("^[A-Z][a-z]*$", customer$first_name), c("customer_id", "first_name")]
    invalid_customer_lastname <- customer[!grepl("^[A-Z][a-z]*$", customer$last_name), c("customer_id", "last_name")]

    #Check email format
    invalid_customer_email <- customer[!grepl("^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$", customer$customer_email), c("customer_id", "customer_email")]

    #Check format of mobile number (+xx xxx xxx xxxx)
    invalid_customer_number <- customer[!grepl("^\\+\\d{1,3}\\s[0-9]{3}\\s[0-9]{3}\\s[0-9]{4}$", customer$customer_phone), c("customer_id", "customer_phone")]

    #Check for missing data
    na_customer_customer_id <- customer[is.na(customer$customer_id), "customer_id"]
    na_customer_first_name <- customer[is.na(customer$first_name), c("customer_id", "first_name")]
    na_customer_last_name <- customer[is.na(customer$last_name), c("customer_id", "last_name")]
    na_customer_gender <- customer[is.na(customer$gender), c("customer_id", "gender")]
    na_customer_customer_email <- customer[is.na(customer$customer_email), c("customer_id", "customer_email")]
    na_customer_customer_phone <- customer[is.na(customer$customer_phone), c("customer_id", "customer_phone")]
    na_customer_street <- customer[is.na(customer$street), c("customer_id", "street")]
    na_customer_city <- customer[is.na(customer$city), c("customer_id", "city")]
    na_customer_country <- customer[is.na(customer$country), c("customer_id", "country")]
    na_customer_postcode <- customer[is.na(customer$postcode), c("customer_id", "postcode")]

    #Remove unclean data
    bad_customer_record <- unique(c(duplicate_customer_id, 
                                    invalid_customer_firstname$customer_id, 
                                    invalid_customer_lastname$customer_id, 
                                    invalid_customer_email$customer_id, 
                                    invalid_customer_number$customer_id))
    customer <- customer[!(customer$customer_id %in% bad_customer_record), ]

    ```

2.  SUPPLIER

    Validation processes for SUPPLIER entity included:

    -   Check if the values of the primary key are unique

    -   Check the format of suppliers' names.

    -   Check the format of the email

    -   Check the format of the mobile number, which should start with a plus sign followed by 12 integer values

    -   Check if there is any missing data in the attributes that should not have missing values

    -   Remove unqualified data value

    ```{r}
    #Check for duplicate primary key
    duplicate_supplier_id <- supplier[duplicated(supplier$supplier_id), "supplier_id"] 

    #Check supplier (can contain alphabets, comma, hyphen, dot)
    invalid_supplier_name <- supplier[!grepl("^[A-Za-z,.-]+( [A-Za-z,.-]+)*$", supplier$supplier_name), c("supplier_id", "supplier_name")]

    #Check email format
    invalid_supplier_email <- supplier[!grepl("^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$", supplier$supplier_email), c("supplier_id", "supplier_email")]

    #Check format of mobile number (+xx xxx xxx xxxx)
    invalid_supplier_number <- supplier[!grepl("^^\\+\\d{1,3}\\s[0-9]{3}\\s[0-9]{3}\\s[0-9]{4}$", supplier$supplier_phone), c("supplier_id", "supplier_phone")]

    #Check for missing data 
    na_supplier_supplier_id <- supplier[is.na(supplier$supplier_id), "supplier_id"]
    na_supplier_supplier_name <- supplier[is.na(supplier$supplier_name), c("supplier_id", "supplier_name")]
    na_supplier_supplier_email <- supplier[is.na(supplier$supplier_email), c("supplier_id", "supplier_email")]
    na_supplier_supplier_phone <- supplier[is.na(supplier$supplier_phone), c("supplier_id", "supplier_phone")]

    #Remove unclean data
    bad_supplier_record <- unique(c(duplicate_supplier_id$supplier_id, 
                                    invalid_supplier_name$supplier_id,
                                    invalid_supplier_email$supplier_id,
                                    invalid_supplier_number$supplier_id))
    supplier <- supplier[!(supplier$supplier_id %in% bad_supplier_record), ]
    ```

3.  CATEGORY

    Validation processes for CATEGORY entity included:

    -   Check if the values of the primary key are unique

    -   Check the datatype of categories' names.

    -   Check if there is any missing data in the attributes that should not have missing values

    -   Remove unqualified data value

        ```{r}
        #Check for duplicate primary key
        duplicate_category_id <- category[duplicated(category$category_id), "category_id"] 

        #Check category (can contain alphabets)
        invalid_category_name <- category[!grepl("^[A-Za-z]+( [A-Za-z]+)*$", category$category_name), c("category_id", "category_name")]

        #Check for duplicate category name
        duplicate_category_name <- category[duplicated(category$category_name), c("category_id", "category_name")]

        #Check for missing data 
        na_category_category_id <- category[is.na(category$category_id), "category_id"]
        na_category_category_name <- category[is.na(category$category_name), c("category_id", "category_name")]

        #Remove unclean data
        bad_category_record <- unique(c(duplicate_category_id$category_id, 
                                        invalid_category_name$category_id,
                                        duplicate_category_name$category_id))
        category <- category[!(category$category_id %in% bad_category_record), ]
        ```

4.  ADVERTISEMENT

    Validation processes for the ADVERTISEMENT entity included:

    -   Check if the values of the primary key are unique

    -   Check the datatype of ad_frequency, which should be integers

    -   Check if there is any negative value in the attributes that the values should only be positive

    -   Check if there is any missing data in the attributes that should not have missing values

    -   Remove unqualified data value

        ```{r}
        #Check for duplicate primary key
        duplicate_ad_id <- advertisement[duplicated(advertisement$ad_id), "ad_id"]

        #Check ad frequency (can only contain integer)
        invalid_ad_frequency <- advertisement[!grepl("^[0-9]+$", advertisement$ad_frequency), c("ad_id", "ad_frequency")]

        #Check for negative ad frequency
        negative_ad_frequency <- advertisement[advertisement$ad_frequency < 0, c("ad_id", "ad_frequency")]

        #Check for negative prices
        negative_ad_prices <- advertisement[advertisement$ad_price < 0, c("ad_id", "ad_price")]

        #Check for missing data 
        na_advertisement_ad_id <- advertisement[is.na(advertisement$ad_id), "ad_id"]
        na_advertisement_ad_frequency <- advertisement[is.na(advertisement$ad_frequency), c("ad_id", "ad_frequency")]
        na_advertisement_ad_price <- advertisement[is.na(advertisement$ad_price), c("ad_id", "ad_price")]
        na_advertisement_ad_place <- advertisement[is.na(advertisement$ad_place), c("ad_id", "ad_place")]

        #Remove unclean data
        bad_advertisement_record <- unique(c(duplicate_ad_id$ad_id, 
                                        invalid_ad_frequency$ad_id,
                                        negative_ad_frequency$ad_id,
                                        negative_ad_prices$ad_id))
        advertisement <- advertisement[!(advertisement$ad_id %in% bad_advertisement_record), ]
        ```

5.  DISCOUNT

    Validation processes for DISCOUNT entity included:

    -   Check if the values of the primary key are unique

    -   Check the datatype of discount_amount, which should be integers

    -   Check if there is any missing data in the attributes that should not have missing values

    -   Remove unqualified data value

        ```{r}
        #Check for duplicate primary key
        duplicate_promo_code <- discount[duplicated(discount$promo_code), "promo_code"]

        #Check percent
        invalid_discount_percent <- discount[!grepl("^[0-9]+$", discount$discount_percent), c("promo_code", "discount_percent")]

        #Check for missing data
        na_discount_promo_code <- discount[is.na(discount$promo_code), "promo_code"]
        na_discount_discount_percent <- discount[is.na(discount$discount_percent), c("promo_code", "discount_percent")]

        #Remove unclean data
        bad_discount_record <- unique(c(duplicate_promo_code$promo_code, 
                                        invalid_discount_percent$promo_code))
        discount <- discount[!(discount$promo_code %in% bad_discount_record), ]

        ```

**Child Entities Validation**

1.  PRODUCT

    Validation processes for PRODUCT entity included:

    -   Check if the values of the primary key are unique

    -   Check the datatype of product_name

    -   Check if there is any negative value in unit_price where the values should only be positive

    -   Check on the validity of stock_on_hand to see if there are any missing or negative values

    -   Check if there are any values of foreign keys, including supplier_id and category_id, in the PRODUCT table that do not exist in the SUPPLIER and CATEGORY table.

    -   Check if the values in main_product_id are self-referential to product_id and ensure that the values differ from those of product_id.

    -   Check if there is any missing data in the attributes that should not have missing values

    -   Remove unqualified data value

        ```{r}
        #Check for duplicate primary key
        duplicate_product_id <- product[duplicated(product$product_id), "product_id"]

        #Check product name (can contain alphabets, comma, hyphen, dot)
        invalid_product_name <- product[!grepl("^[A-Za-z,.-]+( [A-Za-z,.-]+)*$", product$product_name), c("product_id", "product_name")]

        #Check for negative prices
        negative_unit_prices <- product[product$unit_price < 0, c("product_id", "unit_price")]

        #Check invalid stock
        invalid_stock <- product[!grepl("^[0-9]+$", product$stock_on_hand), c("product_id", "stock_on_hand")]
        negative_stock <- product[product$stock_on_hand < 0, c("product_id", "stock_on_hand")]

        #Check if supplier_id exists in the SUPPLIER table
        invalid_supplier_fk <- product[!product$supplier_id %in% supplier$supplier_id, c("product_id", "supplier_id")]

        #Check if category_id exists in the CATEGORY table
        invalid_category_fk <- product[!product$category_id %in% category$category_id, c("product_id", "category_id")]

        #Check if main product is self referential and it cannot be the same as product_id
        invalid_main_product_ids <- product[!is.na(product$main_product_id) & 
                                              !(product$main_product_id %in% product$product_id & 
                                                  product$main_product_id != product$product_id), c("product_id", "main_product_id")]

        #Check for missing data
        na_product_product_id <- product[is.na(product$product_id), "product_id"]
        na_product_category_id <- product[is.na(product$category_id), c("product_id", "category_id")]
        na_product_supplier_id <- product[is.na(product$supplier_id), c("product_id", "supplier_id")]
        na_product_product_name <- product[is.na(product$product_name), c("product_id", "product_name")]
        na_product_unit_price <- product[is.na(product$unit_price), c("product_id", "unit_price")]
        na_product_stock_on_hand <- product[is.na(product$stock_on_hand), c("product_id", "stock_on_hand")]
        na_product_main_product_id <- product[is.na(product$main_product_id), c("product_id", "main_product_id")] #not all order have discount

        #Remove unclean data
        bad_product_record <- unique(c(duplicate_product_id$product_id, 
                                       invalid_product_name$product_id,
                                       negative_unit_prices$product_id,
                                       invalid_stock$product_id,
                                       negative_stock$product_id,
                                       invalid_supplier_fk$product_id,
                                       invalid_category_fk$product_id,
                                       invalid_main_product_ids$product_id))
        product <- product[!(product$product_id %in% bad_product_record), ]

        ```

2.  ORDER_ITEM

    Validation processes for ORDER_ITEM entity included:

    ```{r}

    ```

3.  ORDER_DETAIL

    Validation processes for ORDER_DETAIL entity included:

4.  ADVERTISE_IN

    Validation processes for ADVERTISE_IN entity included:

    -   Check if the values of the composite primary key are unique

    -   Check if there are any values of foreign keys, including ad_id and product_id, in the ADVERTISE_IN table that do not exist in the ADVERTISEMENT and PRODUCT table.

    -   Remove unqualified data value

    ```{r}
    #Check duplicate for composite primary key
    advertise_in_composite_key <- paste(advertise_in$ad_id, advertise_in$product_id)
    duplicate_advertise_in_composite_key <- advertise_in[duplicated(advertise_in_composite_key), c("ad_id", "product_id")]

    #Check if ad_id exists in the ADVERTISEMENT table
    invalid_advertisement_fk <- advertise_in[!advertise_in$ad_id %in% advertisement$ad_id, "ad_id"]

    #Check if product_id exists in the PRODUCT table
    invalid_product_fk <- advertise_in[!advertise_in$product_id %in% product$product_id, c("ad_id", "product_id")]

    #Remove unclean data
    bad_advertise_in_record <- unique(c(duplicate_advertise_in_composite_key$ad_id,
                                        invalid_advertisement_fk$ad_id,
                                        invalid_product_fk$ad_id))
    advertise_in <- advertise_in[!(advertise_in$ad_id %in% bad_advertise_in_record), ]
    ```

## Part 3: Data Pipeline Generation

There are two common workflows for data integration: ELT(Extract, Load, Transform) and ETL (Extract, Transform, Load)

The major difference between ELT and ETL is that in the ELT stage, normalization is performed after the datasets are imported into the database. In the ETL stage, any normalization and transformation of the data is done before it is loaded into the database.

In our work, we chose ETL (Extract, Transform, Load) instead of ELT as our workflow and used SQL and R interchangeably to perform transformations. This is because we have found that ETL workflow is more suitable for small data sets, so we thought that it would be more compromised with our work.

### Task 3.1: GitHub Repository and Workflow Setup

We first created a new public repository on GitHub and created the following files:

1.  README file to include all student ID numbers for our group.
2.  database_schema file as a rmd. file to contain r code for creating a database and building the database schema.
3.  data_validation_and_load file as a rmd. file to create code for validating data and loading the cleaned data into the database.
4.  data_visualization file to perform data analysis and visualise essential results.
5.  There are three folders, including data_upload to store 10 datasets generated by Mockaroo, images to store images attached to the quarto report, and figures to store figures generated by data visualization.
6.  Report as a qmd. file to report the tasks and how they were done.

Secondly, we create a new project in RStudio and connect it to Git for version control to manage code in a local development environment, leading to easier tracking of changes, creating branches, merging code, etc.

GitHub Actions can automate workflows, such as running tests, building, and deploying tasks after pushing code, which can improve development efficiency and ensure code stability. Therefore, we created the .github/workflows directory and an **etl.yaml** file within it.

### Task 3.2: Data Import and Quality Assurance

Our GitHub Actions workflow was designed to execute a task named "ETL workflow for group 3.", triggering by push events to the ‘main’ branch. In this part, we defined a sequence of steps to be executed on the latest version of Ubuntu:

1.  Checkout code: fetch the repository's code.
2.  Set up the R environment and specify the R version as '4.3.3'.
3.  Cache R packages: Caches R packages to avoid reinstalling them on each run.
4.  Install packages: Installs required packages if the cache misses.
5.  Execute RMD files: Executes for data loading tasks.
6.  Push changes: utilizes an authentication token to push changes to the ‘main’ branch.

## Part 4: Data Analysis and Reporting with Quarto in R

### Task 4.1: Advanced Data Analysis in R

```{r}
library(DBI)
library(RSQLite)
library(readr)
library(dplyr)
library(plotly)
```

```{r writebacktodb}
RSQLite::dbWriteTable(connect,"CUSTOMERS",customer,overwrite=TRUE)
RSQLite::dbWriteTable(connect,"ADDRESS",address,overwrite=TRUE)
RSQLite::dbWriteTable(connect,"PRODUCT",product,overwrite=TRUE)
RSQLite::dbWriteTable(connect,"DISCOUNT",discount,overwrite=TRUE)
RSQLite::dbWriteTable(connect,"ORDER_ITEM",order_item,overwrite=TRUE)
RSQLite::dbWriteTable(connect,"ORDER_DETAIL",order_detail,overwrite=TRUE)
RSQLite::dbWriteTable(connect,"SUPPLIER",supplier,overwrite=TRUE)
RSQLite::dbWriteTable(connect,"ADVERTISEMENTS",advertisement,overwrite=TRUE)
RSQLite::dbWriteTable(connect,"ADVERTISE_IN",advertise_in,overwrite=TRUE)
RSQLite::dbWriteTable(connect,"CATEGORY",category,overwrite=TRUE)
```

### Task 4.2: Comprehensive Reporting with Quarto
